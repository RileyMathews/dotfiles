#!/usr/bin/env bash
set -euo pipefail

# gh-tail-failed.sh ‚Äî interactive GitHub Actions run viewer (job-aware)
# ----------------------------------------------------------
# Fetches workflow runs for the latest commit, finds failed jobs,
# lets you pick one via fzf, and tails its last 100 lines of logs.

lines=100
commit=$(git rev-parse HEAD)
branch=$(git rev-parse --abbrev-ref HEAD)

# Ensure required tools exist
for cmd in gh jq; do
  if ! command -v "$cmd" >/dev/null 2>&1; then
    echo "‚ùå Missing dependency: $cmd"
    exit 1
  fi
done

# fzf optional
if ! command -v fzf >/dev/null 2>&1; then
  echo "‚ö†Ô∏è  fzf not found ‚Äî will auto-select the first failed workflow/job"
  fzf_available=false
else
  fzf_available=true
fi

echo "üîç Checking workflows for commit: $commit ($branch)"

# Fetch all runs for this commit (sorted newest first)
runs_json=$(gh run list \
  --commit "$commit" \
  --json name,status,conclusion,databaseId,url,workflowName \
  --limit 50)

# Check if any runs were found
if [[ "$(jq length <<<"$runs_json")" -eq 0 ]]; then
  echo "‚ùå No workflows found for commit $commit."
  exit 1
fi

# Extract failed workflows
failed_runs=$(jq -r '.[] | select(.conclusion == "failure") | "\(.workflowName) (\(.databaseId))"' <<<"$runs_json")

if [[ -n "$failed_runs" ]]; then
  echo "‚ùó Found failed workflows:"
  echo "$failed_runs" | sed 's/^/   - /'

  # Select the workflow run that failed
  if $fzf_available; then
    selected_run_id=$(echo "$failed_runs" | fzf --prompt="Select failed workflow > " | awk -F '[()]' '{print $2}')
  else
    selected_run_id=$(echo "$failed_runs" | head -n 1 | awk -F '[()]' '{print $2}')
  fi

  if [[ -z "$selected_run_id" ]]; then
    echo "‚ùå No selection made. Exiting."
    exit 1
  fi

  echo
  echo "üîé Fetching failed jobs for workflow run: $selected_run_id ..."
  jobs_json=$(gh run view "$selected_run_id" --json jobs)

  # Extract job name + ID pairs for failed jobs
  mapfile -t failed_jobs < <(echo "$jobs_json" | jq -r '.jobs[] | select(.conclusion == "failure") | "\(.name)\t\(.databaseId)"')

  if [[ ${#failed_jobs[@]} -eq 0 ]]; then
    echo "‚ö†Ô∏è  Workflow failed, but no specific job marked as failed (may have been cancelled or infra error)."
    exit 0
  fi

  echo "‚ùå Failed jobs:"
  printf '%s\n' "${failed_jobs[@]}" | cut -f1 | sed 's/^/   - /'

  if $fzf_available; then
    selected_line=$(printf '%s\n' "${failed_jobs[@]}" | cut -f1 | fzf --prompt="Select failed job > ")
  else
    selected_line=$(printf '%s\n' "${failed_jobs[0]}" | cut -f1)
  fi

  if [[ -z "$selected_line" ]]; then
    echo "‚ùå No job selected. Exiting."
    exit 1
  fi

  selected_job_id=$(printf '%s\n' "${failed_jobs[@]}" | grep -F "$selected_line" | cut -f2)

  echo
  echo "üìÑ Tailing last $lines lines of logs for job: $selected_line (ID $selected_job_id)"
  echo "------------------------------------------------------------"
  gh run view "$selected_run_id" --job "$selected_job_id" --log | tail -n "$lines"
  exit 0
fi

# If no workflow failures, show summary
echo "‚úÖ No failed workflows found for commit $commit."
echo
echo "üìä Workflow summary:"
jq -r '
  group_by(.status)[] |
  {status: .[0].status, runs: .} |
  "  ‚Ä¢ " + .status + ": " + (.runs | length | tostring) + " runs"
' <<<"$runs_json"

echo
echo "üìã Per-run details:"
jq -r '
  .[] |
  "  - " + .workflowName + " (" + .status + ", " + .conclusion + ")"
' <<<"$runs_json"

