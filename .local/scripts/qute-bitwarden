#!/usr/bin/env python3

# SPDX-FileCopyrightText: Chris Braun (cryzed) <cryzed@googlemail.com>
#
# SPDX-License-Identifier: GPL-3.0-or-later

"""
Insert login information using Bitwarden CLI and rofi.

The domain of the site has to be in the name of the Bitwarden entry, for example: 
"github.com/cryzed" or "websites/github.com". 

The login information is inserted by emulating key events using qutebrowser's 
fake-key command in this manner: [USERNAME]<Tab>[PASSWORD], which is compatible 
with almost all login forms.

You must log into Bitwarden CLI using `bw login` prior to use of this script.
The session key will be cached in /tmp for 24 hours.

To use in qutebrowser, run: `spawn --userscript qute-bitwarden`

Dependencies: Bitwarden CLI, rofi

WARNING: The login details are viewable as plaintext in qutebrowser's debug log
(qute://log) and might be shared if you decide to submit a crash report!
"""

import enum
import functools
import os
import re
import shlex
import subprocess
import sys
import json
import time
import stat
from urllib.parse import urlparse

# Configuration
DMENU_INVOCATION = 'rofi -dmenu -i -p Bitwarden'
PASSWORD_PROMPT_INVOCATION = 'rofi -dmenu -p "Master Password" -password -lines 0'
IO_ENCODING = 'UTF-8'
AUTO_LOCK_SECONDS = 86400  # 24 hours
SESSION_CACHE_FILE = '/tmp/bw_session_{}'.format(os.getuid())

stderr = functools.partial(print, file=sys.stderr)


class ExitCodes(enum.IntEnum):
    SUCCESS = 0
    FAILURE = 1
    # 1 is automatically used if Python throws an exception
    NO_PASS_CANDIDATES = 2
    COULD_NOT_MATCH_USERNAME = 3
    COULD_NOT_MATCH_PASSWORD = 4


def qute_command(command):
    with open(os.environ['QUTE_FIFO'], 'w') as fifo:
        fifo.write(command + '\n')
        fifo.flush()


def ask_password():
    process = subprocess.run(
        shlex.split(PASSWORD_PROMPT_INVOCATION),
        text=True,
        stdout=subprocess.PIPE,
    )
    if process.returncode > 0:
        raise Exception('Could not unlock vault')
    master_pass = process.stdout.strip()
    return subprocess.check_output(
        ['bw', 'unlock', '--raw', '--passwordenv', 'BW_MASTERPASS'],
        env={**os.environ, 'BW_MASTERPASS': master_pass},
        text=True,
    ).strip()


def get_session_key():
    """
    Get or create a Bitwarden session key with file-based caching.
    The session is cached in /tmp with proper permissions and expires after AUTO_LOCK_SECONDS.
    """
    # Check if cached session exists and is valid
    if os.path.exists(SESSION_CACHE_FILE):
        try:
            # Check file permissions for security
            file_stat = os.stat(SESSION_CACHE_FILE)
            if stat.S_IMODE(file_stat.st_mode) != 0o600:
                stderr(f'Warning: Session cache file has incorrect permissions, removing')
                os.remove(SESSION_CACHE_FILE)
            else:
                # Check if session has expired
                file_age = time.time() - file_stat.st_mtime
                if file_age < AUTO_LOCK_SECONDS:
                    with open(SESSION_CACHE_FILE, 'r') as f:
                        session = f.read().strip()
                        if session:
                            return session
                else:
                    stderr('Session cache expired, prompting for password')
                    os.remove(SESSION_CACHE_FILE)
        except (IOError, OSError) as e:
            stderr(f'Error reading session cache: {e}')
            if os.path.exists(SESSION_CACHE_FILE):
                os.remove(SESSION_CACHE_FILE)
    
    # No valid cached session, ask for password
    session = ask_password()
    if not session:
        raise Exception('Could not unlock vault')
    
    # Cache the session with secure permissions
    try:
        # Create file with restrictive permissions (owner read/write only)
        fd = os.open(SESSION_CACHE_FILE, os.O_CREAT | os.O_WRONLY | os.O_TRUNC, 0o600)
        with os.fdopen(fd, 'w') as f:
            f.write(session)
    except (IOError, OSError) as e:
        stderr(f'Warning: Could not cache session: {e}')
        # Continue anyway, we have the session
    
    return session


def pass_(domain):
    session_key = get_session_key()
    process = subprocess.run(
        ['bw', 'list', 'items', '--nointeraction', '--session', session_key, '--url', domain],
        capture_output=True,
    )

    err = process.stderr.decode(IO_ENCODING).strip()
    if err:
        msg = 'Bitwarden CLI returned for {:s} - {:s}'.format(domain, err)
        stderr(msg)

    if process.returncode:
        return '[]'

    out = process.stdout.decode(IO_ENCODING).strip()

    return out


def dmenu(items):
    command = shlex.split(DMENU_INVOCATION)
    process = subprocess.run(command, input='\n'.join(
        items).encode(IO_ENCODING), stdout=subprocess.PIPE)
    return process.stdout.decode(IO_ENCODING).strip()


def extract_domain_parts(url):
    """
    Extract domain parts from a URL without external dependencies.
    Returns an object with similar attributes to tldextract.
    """
    class DomainParts:
        def __init__(self):
            self.fqdn = ''
            self.registered_domain = ''
            self.subdomain = ''
            self.domain = ''
            self.ipv4 = ''
    
    result = DomainParts()
    parsed = urlparse(url)
    hostname = parsed.hostname or parsed.netloc.split(':')[0]
    
    if not hostname:
        return result
    
    # Check if it's an IPv4 address
    ipv4_pattern = r'^(\d{1,3}\.){3}\d{1,3}$'
    if re.match(ipv4_pattern, hostname):
        result.ipv4 = hostname
        return result
    
    # Split hostname into parts
    parts = hostname.split('.')
    result.fqdn = hostname
    
    if len(parts) >= 2:
        # Simple heuristic: last two parts are domain + TLD (registered_domain)
        result.registered_domain = '.'.join(parts[-2:])
        result.domain = parts[-2]
        
        if len(parts) > 2:
            result.subdomain = '.'.join(parts[:-2])
    elif len(parts) == 1:
        result.domain = parts[0]
    
    return result


def fake_key_raw(text):
    for character in text:
        # Escape all characters by default, space requires special handling
        sequence = '" "' if character == ' ' else r'\{}'.format(character)
        qute_command('fake-key {}'.format(sequence))


def main():
    url = os.getenv('QUTE_URL')
    if not url:
        stderr('Error: QUTE_URL environment variable not set')
        return ExitCodes.FAILURE

    extract_result = extract_domain_parts(url)

    # Try to find candidates using targets in the following order: fully-qualified domain name (includes subdomains),
    # the registered domain name and finally: the IPv4 address if that's what
    # the URL represents
    candidates = []
    for target in filter(
        None,
        [
            extract_result.fqdn,
            extract_result.registered_domain,
            extract_result.subdomain + "." + extract_result.domain if extract_result.subdomain and extract_result.domain else None,
            extract_result.domain,
            extract_result.ipv4,
        ],
    ):
        target_candidates = json.loads(pass_(target))
        if not target_candidates:
            continue

        candidates = target_candidates
        break  # Don't merge candidates, stop at first match

    if not candidates:
        qute_command("message-info 'no candidates found'")
        stderr('No pass candidates for URL {!r} found!'.format(url))
        return ExitCodes.NO_PASS_CANDIDATES

    qute_command(f"message-info '{len(candidates)} found'")
    
    if len(candidates) == 1:
        selection = candidates[0]
    else:
        choices = ['{} | {}'.format(c.get('name', 'NULL'), c.get('login', {}).get('username', 'NULL')) for c in candidates]
        choice = dmenu(choices)
        if not choice:
            return ExitCodes.SUCCESS
        choice_tokens = choice.split('|')
        choice_name = choice_tokens[0].strip()
        choice_username = choice_tokens[1].strip()
        selection = next((c for c in candidates
                          if c['name'] == choice_name
                          and c['login']['username'] == choice_username),
                         None)

    # Nothing was selected, simply return
    if not selection:
        return ExitCodes.SUCCESS

    username = selection['login']['username']
    password = selection['login']['password']

    # Enter username and password using fake-key and <Tab> (which seems to work almost universally), then switch
    # back into insert-mode, so the form can be directly submitted by
    # hitting enter afterwards
    fake_key_raw(username)
    qute_command('fake-key <Tab>')
    fake_key_raw(password)

    qute_command('mode-enter insert')

    return ExitCodes.SUCCESS


if __name__ == '__main__':
    sys.exit(main())
